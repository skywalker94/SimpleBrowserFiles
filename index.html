<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Resource Archive — SimpleBrowserFiles</title>
  <link rel="icon" href="assets/logo.png">
  <link rel="stylesheet" href="assets/site.css" />
</head>
<body>
  <main class="wrap">
    <header class="site-head">
      <div class="top">
        <h1>Resource Archive</h1>
        <span class="tag">SimpleBrowserFiles</span>
      </div>
      <p class="lead">A clean static site for hosting small files. Drop files into <code>files/&lt;Category&gt;/</code> and push to main — <code>files/files.json</code> is generated by the Action.</p>
    </header>

    <section class="controls">
      <label for="search" class="sr-only">Search: </label>
      <div class="search-wrap">
        <input id="search" type="search" placeholder="Search files by name or description — press / to focus" aria-label="Search files" />
        <button id="clearSearch" class="icon" aria-label="Clear search" title="Clear" hidden>&times;</button>
      </div>
    </section>

    <nav class="cats" id="content" aria-live="polite"></nav>

    <footer class="site-foot">
      <p>Hosted on GitHub Pages — repo:
        <a href="https://github.com/skywalker94/SimpleBrowserFiles" target="_blank" rel="noopener">SimpleBrowserFiles</a>
      </p>
    </footer>
  </main>

<script>
const FILES_JSON = 'files/files.json';

// helpers
const esc = s => String(s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
const noop = () => {};

// determine type by extension
function extType(ext){
  ext = (ext||'').toLowerCase();
  if(!ext) return 'other';
  if(['jpg','jpeg','png','gif','webp','svg','bmp','ico'].includes(ext)) return 'image';
  if(['mp4','webm','ogg','mov','m4v'].includes(ext)) return 'video';
  if(['mp3','wav','ogg','m4a','flac'].includes(ext)) return 'audio';
  if(['txt','md','csv','json','log','ini','text'].includes(ext)) return 'text';
  if(['pdf'].includes(ext)) return 'pdf';
  if(['zip','rar','7z','tar','gz'].includes(ext)) return 'archive';
  return 'other';
}

// file card HTML includes a preview stub (lazy-loaded)
function fileCard(item){
  const path = item.path || item.name || '';
  const url = new URL(path, location.href).href;
  const filename = path.split('/').pop() || (item.name || 'file');
  const ext = (filename.split('.').pop() || '').toLowerCase();
  const type = extType(ext);
  const title = esc(item.title || filename);
  const desc = esc(item.description || '');
  return `
    <article class="card preview-${type}" data-path="${esc(path)}" data-ext="${esc(ext)}" tabindex="0">
      <div class="card-preview" aria-hidden="true">
        <!-- preview target: filled by lazy loader -->
        <div class="preview-inner" data-type="${esc(type)}" data-path="${esc(path)}"></div>
      </div>

      <div class="card-main">
        <div class="card-left">
          <div class="card-title">${title}</div>
          <div class="card-desc">${desc}</div>
        </div>
        <div class="card-right">
          <div class="ext ext-${esc(type)}" title="extension">${esc(ext || '')}</div>
        </div>
      </div>

      <div class="card-actions">
        <a class="btn open" href="${url}" target="_blank" rel="noopener" aria-label="Open ${title}">Open</a>
        <button class="btn download" data-path="${esc(path)}" aria-label="Download ${title}">Download</button>
      </div>
    </article>
  `;
}

function categoryBlock(cat){
  const items = cat.items || [];
  const filesHtml = items.map(fileCard).join('');
  return `
    <section class="category">
      <h2 class="cat-title">${esc(cat.name)} <span class="count" title="file count in category"><strong>${items.length}</strong></span></h2>
      <div class="grid">${filesHtml || '<p class="empty">No files</p>'}</div>
    </section>
  `;
}

function render(data){
  const container = document.getElementById('content');
  if(!data || !Array.isArray(data.categories)){
    container.innerHTML = '<p class="error">No files manifest found. Add <code>files/files.json</code> or enable the auto-generator.</p>';
    return;
  }
  container.innerHTML = data.categories.map(categoryBlock).join('');
  attachInteractions();
  initPreviewLazyLoader();
}

/* ---------- interactions: downloads & keyboard ---------- */
function attachInteractions(){
  const content = document.getElementById('content');

  // Download handler (delegated)
  content.addEventListener('click', async (e) => {
    const dlBtn = e.target.closest('.btn.download');
    if(!dlBtn) return;
    e.preventDefault();
    const path = dlBtn.getAttribute('data-path');
    if(!path) return;
    const url = new URL(path, location.href).href;
    try {
      const a = document.createElement('a');
      a.href = url;
      const filename = path.split('/').pop();
      a.setAttribute('download', filename);
      a.style.display='none';
      document.body.appendChild(a);
      a.click();
      a.remove();
      showTempState(dlBtn, 'Downloaded');
      return;
    } catch (err) { /* fallback */ }

    try {
      const resp = await fetch(path);
      if(!resp.ok) throw new Error('Network error');
      const blob = await resp.blob();
      const blobUrl = URL.createObjectURL(blob);
      const a2 = document.createElement('a');
      a2.href = blobUrl;
      a2.download = path.split('/').pop();
      document.body.appendChild(a2);
      a2.click();
      a2.remove();
      URL.revokeObjectURL(blobUrl);
      showTempState(dlBtn, 'Downloaded');
    } catch (err) {
      console.error('Download failed', err);
      showTempState(dlBtn, 'Failed');
    }
  });

  // keyboard: Enter/Space on card opens file link
  content.addEventListener('keydown', (e) => {
    const card = e.target.closest('.card');
    if(!card) return;
    if(e.key === 'Enter' || e.key === ' '){
      e.preventDefault();
      const link = card.querySelector('.btn.open');
      if(link) link.click();
    }
  }, true);
}

function showTempState(buttonEl, text){
  const orig = buttonEl.innerHTML;
  buttonEl.textContent = text;
  buttonEl.disabled = true;
  setTimeout(()=>{ buttonEl.innerHTML = orig; buttonEl.disabled = false; }, 1400);
}

/* ---------- preview lazy loader ---------- */
function initPreviewLazyLoader(){
  const io = new IntersectionObserver((entries, obs) => {
    entries.forEach(entry => {
      if(!entry.isIntersecting) return;
      obs.unobserve(entry.target);
      loadPreviewFor(entry.target);
    });
  }, { root: null, rootMargin: '200px', threshold: 0.06 });

  document.querySelectorAll('.preview-inner').forEach(el => io.observe(el));
}

async function loadPreviewFor(previewEl){
  const type = previewEl.dataset.type;
  const path = previewEl.dataset.path;
  if(!type || !path) return;
  const wrapper = previewEl;

  try {
    if(type === 'image'){
      const img = document.createElement('img');
      img.alt = previewEl.closest('.card').querySelector('.card-title')?.textContent || '';
      img.decoding = 'async';
      img.loading = 'lazy';
      img.src = new URL(path, location.href).href;
      img.className = 'preview-img';
      wrapper.appendChild(img);
      return;
    }

    if(type === 'text'){
      // fetch small snippet
      const resp = await fetch(path);
      if(!resp.ok) throw new Error('fetch fail');
      const text = await resp.text();
      const snippet = text.slice(0, 320).replace(/\s+/g, ' ').trim();
      const pre = document.createElement('pre');
      pre.className = 'preview-text';
      pre.textContent = snippet + (text.length > 320 ? ' …' : '');
      wrapper.appendChild(pre);
      return;
    }

    if(type === 'audio'){
      const audio = document.createElement('audio');
      audio.controls = true;
      audio.preload = 'metadata';
      audio.src = new URL(path, location.href).href;
      audio.className = 'preview-audio';
      wrapper.appendChild(audio);
      return;
    }

    if(type === 'video'){
      const video = document.createElement('video');
      video.controls = true;
      video.muted = true;
      video.playsInline = true;
      video.preload = 'metadata';
      video.className = 'preview-video';
      video.src = new URL(path, location.href).href;
      wrapper.appendChild(video);
      return;
    }

    if(type === 'pdf'){
      const iframe = document.createElement('iframe');
      iframe.className = 'preview-pdf';
      iframe.src = new URL(path, location.href).href;
      iframe.title = 'PDF preview';
      wrapper.appendChild(iframe);
      return;
    }

    // fallback icon / label for other types
    const box = document.createElement('div');
    box.className = 'preview-blank';
    box.innerHTML = `<div class="file-type-tag">${esc(previewEl.closest('.card').dataset.ext || '').toUpperCase()}</div>`;
    wrapper.appendChild(box);
    return;

  } catch (err) {
    // graceful fallback: show extension tag
    const box = document.createElement('div');
    box.className = 'preview-blank';
    box.innerHTML = `<div class="file-type-tag">${esc(previewEl.closest('.card').dataset.ext || '').toUpperCase()}</div>`;
    wrapper.appendChild(box);
    console.warn('Preview load failed', err);
  }
}

/* ---------- search & init ---------- */
function setupSearch(data){
  const input = document.getElementById('search');
  const clearBtn = document.getElementById('clearSearch');

  function filter(q){
    q = (q||'').trim().toLowerCase();
    if(!q){
      render(data);
      clearBtn.hidden = true;
      return;
    }
    clearBtn.hidden = false;
    const filtered = {
      categories: data.categories.map(cat => {
        const items = (cat.items||[]).filter(it=>{
          const hay = ((it.title||it.name||'') + ' ' + (it.description||'') + ' ' + (it.name||'')).toLowerCase();
          return hay.includes(q);
        });
        return { name: cat.name, items };
      }).filter(c => (c.items && c.items.length))
    };
    render(filtered);
  }

  let t = null;
  input.addEventListener('input', () => {
    clearTimeout(t);
    t = setTimeout(()=> filter(input.value), 160);
  });
  clearBtn.addEventListener('click', () => { input.value = ''; clearBtn.hidden = true; render(data); input.focus(); });

  // "/" focus shortcut
  document.addEventListener('keydown', (e) => {
    if(e.key === '/' && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA'){
      e.preventDefault();
      input.focus();
    }
  });
}

// bootstrap
fetch(FILES_JSON)
  .then(r => { if(!r.ok) throw new Error('Failed to load ' + r.status); return r.json(); })
  .then(data => {
    render(data);
    setupSearch(data);
  })
  .catch(err => {
    console.error(err);
    const content = document.getElementById('content');
    content.innerHTML = '<p class="error">Failed loading files manifest. See README or enable the auto-generator.</p>';
  });
</script>
</body>
</html>
